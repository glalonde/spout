#version 450 core
#include "particle.h"
#include "grid.h"
#include "hash.h"
#include "noise.h"
layout(local_size_x = 512, local_size_y = 1, local_size_z = 1) in;
layout(std430, binding = 0) buffer Particles {
  Particle particles[];
};

layout(std140, set = 0, binding = 1) uniform Params {
    uint start_index;
    uint num_emitted;
    uvec2 position_start;
    uvec2 position_end;
    float speed_min;
    float speed_max;
    float angle_start;
    float angle_end;
    float angle_spread;
    float ttl_min;
    float ttl_max;
    float time;
};

const float PI = 3.1415926535897932384626433832795;
const float PI_2 = 1.57079632679489661923;

// This should be a uniform...
const float DT = 1.0 / 60.0;

// a % b
float signed_mod(float a, float b) {
  return a - floor(a/b) * b;
}

// Returns signed a - b
float angle_difference(float a, float b) {
  // https://stackoverflow.com/questions/1878907/the-smallest-difference-between-2-angles
  return signed_mod(a - b + PI_2, PI) - PI_2;
}

void main() {
  int gid = int(gl_GlobalInvocationID.x);
  int total_particles = int(gl_NumWorkGroups * gl_WorkGroupSize);

  // "progress" in terms of number of emitted particles.
  int distance = gid - int(start_index);
  if (distance < 0) {
    // Wrap over the circular buffer.
    distance += total_particles;
  }
  if (distance >= num_emitted) {
    return;
  }


  // Interpolation parameter for time of iteration.
  float interp = float(distance) / num_emitted;

  // Interpolated time through the iteration.
  float interp_time = interp * DT + time;

  // Linear interpolate position 
  vec2 pos_delta = interp * vec2(position_end - position_start);

  // First rand is for velocity
  float rand1 = hash12(vec2(interp, interp_time));

  // First rand is for ttl 
  float rand2 = hash12(vec2(interp, rand1));

  // First rand is for angle
  float rand3 = hash12(vec2(interp, rand1));

  float angle_delta =  angle_difference(angle_end, angle_start);
  float interp_angle = mix(angle_start, angle_start + angle_delta, interp);
  float spray_angle = interp_angle + noise1d(interp_time) - .5 + (rand3 - 0.5) * .05;
  vec2 unit_emit_rotation = vec2(cos(spray_angle), sin(spray_angle));

  
  float rand_speed = mix(speed_min, speed_max, rand2);
  vec2 float_velocity = unit_emit_rotation * rand_speed; 

  // Adjustment from travel during the emission iteration. 
  vec2 position_adjustment = float_velocity * (DT * (1.0 - interp));

  particles[gid].position = position_start + ivec2(pos_delta + position_adjustment);
  particles[gid].velocity = ivec2(float_velocity);
  particles[gid].ttl = mix(ttl_min, ttl_max, rand2);
}